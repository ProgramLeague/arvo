use std::collections::HashMap;

use super::token::{Tok, Error};
use term::*;

// May be worth looking at the grammar from this:
// https://github.com/jroesch/hubris/blob/290c/src/Hubris/Parser/Internal.y

grammar<'input>(text: &'input str)["LALR(1)"];

pub Program : Program = {
    <cs: Commands> => panic!();
};

Commands : Vec<Command> = {
    <cs: Commands> <c:Command> "." => {
        let mut cs = cs;
        cs.push(c);
        cs
    };
    <cs: Commands> <c:"Comment"> => cs;
    => Vec::new();
};

pub Command : Command = {
    "def" <v:Variable> ":" <ty:Term> ":=" <body:Term> => {
        Command::Def(v, ty, body)
    };
    "print" <v:Variable> => Command::Print(v);
    "check" <t:Term> <opt_ty: (":" <Term>)?> => Command::Check(t, opt_ty);
    "simpl" <t:Term> => Command::Simpl(t);
    "data" <v:Variable> <ps: Param*> ":=" <c:Constructor?> <cs: ("|" <Constructor>)*> => {
        let mut cs = cs;
        match c {
            None => {},
            Some(cons) => cs.push(cons),
        }
        Command::Data(v, ps, cs)
    };
    "axiom" <v:Variable> ":" <t:Term> => Command::Axiom(v, t);
    "import" <v:Variable> => Command::Import(v);
};

Constructor : (Variable, Option<Term>) = {
    <v:Variable> <t:(":" <Term>)?> => (v, t);
};

Param : (Variable, Term) = {
    "(" <v:Variable> ":" <t:Term> ")" => (v, t);
};

Term : Term = {
    Lambda;
    Factor;
};

Lambda : Term = {
    "lambda" <v:BoundVariable> <ty:(":" <Term>)?> "." <body:Term> => panic!();
};

Factor : Term = {
    <arg:Expr> "->" <ret:Expr> => {
        match arg {
            
        }
    };
    <e:Expr> => e;
};

Expr : Term = {
    <a:App> => panic!();
};

App : Term = {
    <f:Base> <g:Base> => Term::App(Box::new(f), Box::new(g));
};

Base : Term = {
    "Type" => Term::Type;
    "?" => Term::Hole;
    "_" => panic!();
    <v:Variable> => Term::Var(v);
    "(" <t:Term> ")" => t;
    "(" <t:Term> ":" <ty:Term> ")" => Term::Ascribe(t, ty);
};

BoundVariable : Term = {
    "_" => panic!();
    <v:Variable> => panic!();
};

Variable : Variable = {
    <v:DummyVariable> => Variable { name: v.to_owned() };
};

// This rule is get around the lifetime not being used
// when its actually being used.

DummyVariable: &'input str = {
    <v:"Var"> => v;
};

extern {
    type Location = usize;
    type Error = Error;

    enum Tok<'input> {
        "def"      => Tok::Def(..),
        "axiom"    => Tok::Axiom(..),
        "import"   => Tok::Import(..),
        "print"    => Tok::Print(..),
        "check"    => Tok::Check(..),
        "simpl"    => Tok::Simpl(..),
        "data"     => Tok::Data(..),
        "Type"     => Tok::Type(..),
        "Comment"  => Tok::Comment(<&'input str>),
        "Var"      => Tok::Var(<&'input str>),
        ":"        => Tok::Colon(..),
        ":="       => Tok::ColonEquals(..),
        "."        => Tok::Dot(..),
        "("        => Tok::LeftParen(..),
        ")"        => Tok::RightParen(..),
        "_"        => Tok::Underscore(..),
        "->"       => Tok::RightArrow(..),
        "|"        => Tok::Bar(..),
        "?"        => Tok::Question(..),
        "lambda"   => Tok::Backslash(..),
    }
}
